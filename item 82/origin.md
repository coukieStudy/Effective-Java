# 스레드 안정성 수준을 문서화하라

- 한 메서드를 여러 스레드가 동시에 호출할 때 어떤 일이 일어나는가? 이것을 문서화해야 한다.
- `synchronized` 키워드를 쓴다고 스레드 안전하지 않다. 이건 API 문서에도 들어가지 않는다.
- 클래스가 지원하는 스레드 안정성 수준을 정확히 명시해야 한다.
- 스레드 안정성 수준
    - 불변: 이 클래스의 인스턴스는 변하지 않는다. 외부 동기화도 필요 없다. `String`, `Long`, `BigInteger` 등.
    - 무조건적 스레드 안전: 이 클래스의 인스턴스는 수정될 수 있으나 내부에서 충분히 동기화하기 때문에 외부 동기화가 필요 없다. `AtomicLong`, `ConcurrentHashMap` 등.
    - 조건부 스레드 안전: 무조건적 스레드 안전과 같으나 일부 메서드는 외부 동기화가 필요하다. `Collections.synchronized` 래퍼 메서드들이 여기에 속함.
    - 스레드 안전하지 않음: 이 클래스의 인스턴스는 수정될 수 있다. 따라서 각각의 메서드 호출을 클라이언트가 동기화해야 한다. `ArrayList`, `HashMap` 등.
    - 스레드 적대적: 이 클래스는 메서드 호출을 외부 동기화해도 스레드 안전하지 않다. 이런 클래스는 문제를 고치거나 deprecated API로 지정해야 한다. 코드 78-4의 예시가 여기에 속함.
- 위 분류의 안정성 수준들은 각각 `@Immutable`, `@ThreadSafe`, `@NotThreadSafe`와 대략 일치한다.
- 조건부 스레드 안전한 클래스는 문서화할 때 다음과 같은 사항을 명시해야 한다.
    - 어떤 순서로 호출할 때 외부 동기화가 필요한지
    - 그 순서로 호출하려면 어떤 락을 얻어야 하는지
- 일반적으로 인스턴스 자체를 락으로 얻지만 그렇지 않은 경우도 있다.
    - 예시: `Collections.synchronizedMap` (https://docs.oracle.com/javase/8/docs/api/)
- 독특한 특성의 메서드는 해당 메서드의 주석에 스레드 안정성을 기재하자.
    - 정적 팩토리의 경우 자신이 반환하는 객체의 스레드 안정성을 반드시 문서화해야 한다. (ex. `Collections.synchronizedMap`)
- `synchronized` 같은 공개된 락은 클라이언트에서 일련의 메서드 호출을 원자적으로 수행할 수 있게 해주지만, 다음과 같은 대가가 따른다.
    - 고성능의 내부 동기화와 혼용할 수 없다. (`ConcurrentHashMap` 등)
    - 클라이언트가 공개된 락을 반환하지 않는 서비스 거부 공격에 취약하다. -> 비공개 락 객체를 사용하자.
    ```java
    // 락 필드는 항상 final로 선언하라
    private final Object lock = new Object();

    public void foo() {
        synchronized(lock) {
            ...
        }
    }
    ```
- 조건부 스레드 안전 클래스는 특정 호출 순서에 필요한 락이 무엇인지 클라이언트에게 공개해야 하므로 비공개 락 객체 관용구를 사용할 수 없다.
- 비공개 락 객체 관용구는 상속용으로 설계한 클래스에 특히 잘 맞는다.
    - 상속용 클래스에서 자신의 인스턴스를 락으로 사용하면 하위 클래스가 그것을 방해할 수 있다.


